<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nginx代理</title>
    <link href="/2021/08/09/nginx-arrow/"/>
    <url>/2021/08/09/nginx-arrow/</url>
    
    <content type="html"><![CDATA[<p>业务场景: </p><ol><li>公司有一移动端H5页面图片比较多, 即便做了图片压缩, 图片懒加载, 加载速度还是不够理想, 需要在Nginx做了图片缓存加快加载速度</li><li>公司系统过多, 为解决一个登录页可登录不同应用(每个系统对应不同的<code>client_id</code>), 在公用的登陆页面中登录的时候, 带上获得的授权码<code>code</code>重定向到对应系统A, 系统A获取到授权码<code>code</code> 发送<code>code&amp;&amp;client_id&amp;&amp;client_secret</code>到后端进行安全校验, 基于安全性的考虑,系统A的<code>client_secret</code>不可放在前端代码中, 需要设置Nginx代理请求头</li></ol><h2 id="1-图片缓存"><a href="#1-图片缓存" class="headerlink" title="1. 图片缓存"></a>1. 图片缓存</h2><h3 id="1-1-nginx路径匹配优先级"><a href="#1-1-nginx路径匹配优先级" class="headerlink" title="1.1 nginx路径匹配优先级"></a>1.1 nginx路径匹配优先级</h3><ol><li>全路径匹配 <code>location = path</code></li><li>前缀匹配  <code>location ^~ path</code></li><li>正则匹配 区分大小写: <code>location ~ path</code> 不区分大小写: <code>location ~* path</code></li><li>路径匹配 <code>location path</code></li></ol><h3 id="1-2-设置图片缓存区"><a href="#1-2-设置图片缓存区" class="headerlink" title="1.2 设置图片缓存区"></a>1.2 设置图片缓存区</h3><p>通过 <code>http.proxy_cache_path</code> 配置项设置图片缓存区</p><pre><code class="hljs nginx"><span class="hljs-comment"># /home/nginx 缓存内容存放路径</span><span class="hljs-comment"># levels 存放目录的结构, 可以使用任意的1位或2位数字作为目录结构, 最多三级</span><span class="hljs-comment"># keys_zone=images:10m 内存缓冲区命名为images,内存大小10m</span><span class="hljs-comment"># max_size=2000m 磁盘最多缓存2000m文件, 如果超过则会删除最少使用的文件</span><span class="hljs-comment"># inactive=10 如果文件10分钟内没有被访问, 将会从缓存中删除</span><span class="hljs-comment"># ----下面两个配置是加载器的启动策略, 防止nginx在启动后的几分钟里变得缓慢</span><span class="hljs-comment"># loader_threshold=300 缓存加载器每次迭代过程最多执行300毫秒</span><span class="hljs-comment"># loader_files=200  缓存加载器加载器每次迭代过程中最多加载200个文件</span>http&#123;  <span class="hljs-attribute">proxy_cache_path</span> /home/nginx levels=<span class="hljs-number">1</span>:<span class="hljs-number">2</span> keys_zone=images:<span class="hljs-number">10m</span> loader_threshold=<span class="hljs-number">300</span> loader_files=<span class="hljs-number">200</span> max_size=<span class="hljs-number">2000m</span> inactive=<span class="hljs-number">10d</span>;&#125;</code></pre><h3 id="1-3-设置图片缓存"><a href="#1-3-设置图片缓存" class="headerlink" title="1.3 设置图片缓存"></a>1.3 设置图片缓存</h3><pre><code class="hljs nginx"><span class="hljs-comment">#expires 可设置浏览器设置的过期时间</span><span class="hljs-comment">#proxy_pass 可设置代理的文件服务器路径</span><span class="hljs-comment">#add_header Nginx-Cache &quot;$upstream_cache_status&quot;; 可用于查看缓存是否命中 MISS/HIT</span>  <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /group.*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz)$</span> &#123;      <span class="hljs-attribute">proxy_pass</span> <span class="hljs-variable">$&#123;FILE_REQUEST_DOMAIN_PREFIX&#125;</span>;      <span class="hljs-attribute">proxy_cache</span> images;      <span class="hljs-attribute">expires</span> <span class="hljs-number">30d</span>;      <span class="hljs-attribute">add_header</span> Nginx-Cache <span class="hljs-string">&quot;$upstream_cache_status&quot;</span>;  &#125;</code></pre><h2 id="2-location-proxy-set-header"><a href="#2-location-proxy-set-header" class="headerlink" title="2. location.proxy_set_header"></a>2. location.proxy_set_header</h2><p><strong>这种事肯定是后端做的啦, 这样的架构本身就有问题</strong></p><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">location</span> /api&#123;      <span class="hljs-attribute">proxy_set_header</span> Authorization <span class="hljs-string">&quot;client_secret&quot;</span>;    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端自动发布</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nexus私服</title>
    <link href="/2021/07/05/nexus3/"/>
    <url>/2021/07/05/nexus3/</url>
    
    <content type="html"><![CDATA[<p>写了一个简单版(git clone)功能的node脚手架工具, 在部署到公司nexus私服的过程中遇到了一些问题, 发现自己对nexus私服不是很熟悉(我司的nexus私服, 是乙方人员搭建的, 架构师疲于业务), 遂自己在本地练习了一波nexus搭建npm repository, 发布脚手架, 记录自己部署过程遇到的问题</p><h3 id="nexus搭建"><a href="#nexus搭建" class="headerlink" title="nexus搭建"></a>nexus搭建</h3><ol><li><p>起容器</p><pre><code class="hljs shell">docker run -d -p 10001:8081 --name nexus3 --mount src=nexus-data,target=/nexus-data sonatype/nexus3d16fae5c6f7f27c9de96efdc20eddd2c8ef7b9aaf8a39c317716d380a7e82c56docker psCONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                         NAMESd16fae5c6f7f   sonatype/nexus3   &quot;sh -c $&#123;SONATYPE_DI…&quot;   6 seconds ago   Up 4 seconds   0.0.0.0:10001-&gt;8081/tcp, :::10001-&gt;8081/tcp   nexus3</code></pre></li><li><p>查看容器日志是否启动成功</p><pre><code class="hljs shell">docker logs d16f -f</code></pre><p>查看容器日志启动成功后, 访问本地10001端口即可看到nexus界面</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/start.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/10001.jpg"></div></div></div></li><li><p>登录nexus<br>默认账号: admin, 密码需要到<strong>挂载的卷nexus-data中找到admin.password文件</strong><br><a href="#win10" style="text-decoration: underline; cursor: pointer"><em>win10如何查看docker数据卷</em></a><br>查看卷下的admin.password文件便可查看密码; 登录,登录后设置新密码</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/psd.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/login.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/newpsd.jpg"></div></div></div></li></ol><p><strong>就这样, nexus部署成功</strong></p><h3 id="npm-repository创建"><a href="#npm-repository创建" class="headerlink" title="npm repository创建"></a>npm repository创建</h3><ol><li>先创建一个新的Blob Stores,相当于一个新的文件夹(存放npm hosted类型repository的内容), 可以在数据卷找到这个文件夹<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/blob1.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/blob2.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/blob3.png"></div></div></div></li><li>创建三种类型的 npm repository<p class="note note-primary">npm hosted: 私有仓库, 用于存储内部发布的npm包</p><p class="note note-primary">npm proxy: 代理仓库, 代理例如淘宝源镜像</p><p class="note note-primary">npm group: 仓库组, 组合其他仓库</p></li></ol><p><img src="/img/nexus/npm3.jpg"><br>创建三种类型的 npm repository</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/hosted.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/proxy.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/group.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/cpy.jpg"></div></div></div><h3 id="写一个简单的脚手架"><a href="#写一个简单的脚手架" class="headerlink" title="写一个简单的脚手架,"></a>写一个简单的脚手架,</h3><p>这个脚手架的用法: <code>arrow init demo</code>, 相当于 <code>git clone xxx.git demo</code></p><ol><li><code>npm init -y</code> 初始化</li><li>主要代码实现(虽然只有 git clone 功能)<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/pkg.png"></div><div class="group-image-wrap"><img src="/img/nexus/sh.png"></div></div></div></li><li>本地测试<br><code>npm link</code> 相当于发布到本地全局node_modules包, 包名是package.json里的name, 脚本名为package.json#bin的属性名<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/link.png"></div><div class="group-image-wrap"><img src="/img/nexus/suc.png"></div></div></div></li></ol><h3 id="npm-publish"><a href="#npm-publish" class="headerlink" title="npm publish"></a>npm publish</h3><p><a href="#error">必看: <strong>发布npm包遇到的错误</strong></a></p><ol><li><code>npm login</code>, 注意此处仓库地址是npm hosted 类型的仓库(否则会报400的错误)<br><img src="/img/nexus/npmlogin.png"></li><li><code>npm publish</code>, 以及nexus添加前后对比<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/npmpublish.png"></div><div class="group-image-wrap"><img src="/img/nexus/bp.jpg"></div><div class="group-image-wrap"><img src="/img/nexus/ap.jpg"></div></div></div></li><li>本地测试<br>首先unlink本地全局包, nrm添加源(此处用npm group类型的仓库地址), 安装脚手架<div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/ul.png"></div><div class="group-image-wrap"><img src="/img/nexus/nrm.png"></div><div class="group-image-wrap"><img src="/img/nexus/end.png"></div></div></div></li></ol><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><h3 id="win10查看docker数据卷"><a href="#win10查看docker数据卷" class="headerlink" title="win10查看docker数据卷"></a><span id="win10">win10查看docker数据卷</span></h3><ol><li><a href="https://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">microsoft官方文档开启Hyper-V</a></li><li>打开Hyper-V,连接dockerDesktop<br><img src="/img/nexus/hyper-v.jpg"></li><li><code>cd /var/lib/docker/volumes</code> 便能查看到docker的数据卷 </li></ol><h3 id="发布npm包遇到的错误"><a href="#发布npm包遇到的错误" class="headerlink" title="发布npm包遇到的错误"></a><span id="error">发布npm包遇到的错误</span></h3><ol><li>404, 无法找到包<p class="note note-danger"> Not Found - PUT https://registry.npmjs.org/arrow-cli - Not found</p></li></ol><p><strong>出现原因左图, 解决办法: 右图</strong></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/404.png"></div><div class="group-image-wrap"><img src="/img/nexus/pkg2.png"></div></div></div><ol start="2"><li>401<p class="note note-danger">Unable to authenticate, need: BASIC realm="Sonatype Nexus Repository Manager"</p></li></ol><p><strong>出现原因左图, 解决办法: 右图</strong></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/nexus/401.png"></div><div class="group-image-wrap"><img src="/img/nexus/E401.jpg"></div></div></div>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>nexus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css3 画一个长方体</title>
    <link href="/2021/06/21/css3-3d/"/>
    <url>/2021/06/21/css3-3d/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/css/css3d.gif"><br>源代码查看: <a href="https://codepen.io/honorgo/pen/PopgVrr">codepen</a><br>注意点: </p><ol><li><strong>当元素设置rotate属性时, 其坐标系也会跟着旋转</strong></li><li>坐标系方向:<br><img src="/img/css/zuobiaoxi.png"></li></ol><ul><li>x/y/z轴正方向分别为: 右, 下, 外</li><li>旋转方向判断: 左手握住旋转轴, 拇指指向旋转轴正方向, 手指卷曲方向即为旋转方向(顺时针方向)</li></ul><ol start="3"><li>perspective 视距, 模拟透视效果时人眼的位置<br><img src="/img/css/perspective.jpg"></li><li>设置<code>perspective</code>属性的时候, 要设置在具有<code>transform-style: preserve-3d</code>属性的块的父块上, 不然看到的就像一个梯形<br><img src="/img/css/tixing.gif"></li><li>要让长方体绕中间轴进行旋转, 需要两个点确定中心轴</li></ol><ul><li><code>transform-origin</code> 默认center / (0,0,0), 详细可看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN</a></li><li><code>transform: rotate3d(x, y, z, 0deg)</code><br>旋转轴为连接<code>origin</code>的坐标(起始点), 到<code>rotate3d</code> 的点(终点)的向量</li></ul><ol start="6"><li><code>transform-style: preserve-3d;</code> 设置<strong>子元素</strong>位于3D平面中</li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git进阶</title>
    <link href="/2021/06/18/git/"/>
    <url>/2021/06/18/git/</url>
    
    <content type="html"><![CDATA[<p>记录自己对git的理解, 得益于此篇<a href="https://mp.weixin.qq.com/s/65XK7vpmLhFjQsBB9SBZdA">推文</a>, 推开了git世界的大门, 文中动图来自于此推文; 其他代码图片, 借助<a href="https://carbon.now.sh/">carbon</a>生成</p><h1 id="detached-HEAD-state"><a href="#detached-HEAD-state" class="headerlink" title="detached HEAD state"></a>detached HEAD state</h1><p>头指针分离: HEAD 指针指向非最新的commit_id, 如果有需要可以创建分支以保存;<br>应用场景: 个人常用于测试某些不确定性的功能, 测试可以则保存，测试不满意则丢弃<br><img src="/img/git/head.png"></p><h1 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h1><h2 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h2><p>当前分支相比于我们要合并的分支有额外的提交, 会长生 merge_commit<br><img src="/img/git/nff.gif"></p><h2 id="–ff"><a href="#–ff" class="headerlink" title="–ff"></a>–ff</h2><p>当前分支相比于我们要合并的分支没有额外的提交<br><img src="/img/git/ff.gif"></p><h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>git rebase -i (start_commit_id end_commit_id], start end的区间是<strong>前开后闭</strong>的;<br><strong>变基的前提, 要变基的分支没有合并到其他分支</strong></p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p><strong>更改commit/message/删除commit/修改某个commit/合并多个commit</strong><br><code>git rebase -i start_commit_id end_commit_id</code></p><ul><li>pick        use commit<br>保留此commit与commit-message</li><li>reword    use commit but edit message<br>保留此commit与commit-message但编辑commit-message</li><li>edit        use commit but stop amending<br>保留此commit与commit-message但对文件内容进行编辑 (类似<code>git commit --amend</code>)</li><li>squash    use commit but meld into previous commit<br>保留此commit与commit-message, 但把更改合并到前一个commit</li><li>fixup        like squash but discard this commit’s log commit<br>保留此commit,把更改合并到前一个commit</li><li>drop        remove commit<br>去除此commit与commit-message</li></ul><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p><strong>复制一段连续的commit到指定分支</strong> <code>git rebase -i start_commit_id end_commit_id --onto branch_name</code><br><img src="/img/git/rebase-copy.png"><br><code>git cherry-pick commit_id</code> 可以复制某个commit_id到当前分支, 多个用空格隔开</p><h2 id="避免merge-commit"><a href="#避免merge-commit" class="headerlink" title="避免merge_commit"></a>避免merge_commit</h2><p><code>git rebase branch</code> 把当前分支的提交复制到某分支上, 如果想保持分支的整洁线性 可以使用 git rebase, 在合并分支之前解决冲突, 可以保证不会产生merge_commit<br><img src="/img/git/base.gif"><br><code>git merge</code> 与 <code>git rebase</code> 哪个更好, 个人偏向于<code>git merge</code> 因为保留了很多细节功能迭代历史, 如果项目组管理只需要关注版本迭代的话, 确实<code>git rebase</code>更好</p><h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><h2 id="git-reset-–mixed"><a href="#git-reset-–mixed" class="headerlink" title="git reset –mixed"></a>git reset –mixed</h2><p><strong>用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变</strong></p><h2 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h2><p><strong>丢弃commit, HEAD指针指向指定commit</strong><br><img src="/img/git/reset.gif"></p><h2 id="git-reset-–soft"><a href="#git-reset-–soft" class="headerlink" title="git reset –soft"></a>git reset –soft</h2><p><strong>丢弃commit, HEAD指针指向指定commit, 但保存丢弃的commit的修改</strong><br><img src="/img/git/soft-reset.gif"></p><h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>当要丢弃当前分支过去的某commit_id的时候,除了rebase-drop之外, 还可以使用<code>git revert</code>(git log会记录此操作)<br>曾遇到场景: 丢弃CRM分页条件查询限制<br><img src="/img/git/revert.gif"></p><p>最后, 可以通过第三方包规范git提交格式, 比如<code>cz-conventional-changelog</code></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react入坑指南</title>
    <link href="/2020/10/10/react-base/"/>
    <url>/2020/10/10/react-base/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么入坑"><a href="#为什么入坑" class="headerlink" title="为什么入坑"></a>为什么入坑</h2><p>  无他, 给自己充充电 (<em>之前有人问会不会<code>react + electron</code>, 汗颜: 不会</em>)</p><h2 id="react诞生背景"><a href="#react诞生背景" class="headerlink" title="react诞生背景"></a>react诞生背景</h2><p>  网上说facebook开发团队开发facebook首页状态栏, 要实时显示当前好友请求, 消息列表、状态列表; 但是当功能上线的时候会出现: 如果有一条新的消息出现不能够及时的刷新显示的数字, 但点开一条新的消息数字又不能够立即的修改<br>  于是乎, react为了解决<strong>状态分散难以追踪和维护</strong>的问题(没有接触过传统MVC的项目, 个人是体验不到这种痛苦的)</p><h2 id="react-v16-的学习"><a href="#react-v16-的学习" class="headerlink" title="react v16+ 的学习"></a>react v16+ 的学习</h2><h3 id="1-脚手架创建项目"><a href="#1-脚手架创建项目" class="headerlink" title="1. 脚手架创建项目"></a>1. 脚手架创建项目</h3>  <pre><code class="hljs shell">npx create-react-app react-base</code></pre><p>  <em>和vue-cli的一点区别: 没有过多的配置项, 只是简单的生成一个项目</em></p><h3 id="2-样式-自带样式作用域"><a href="#2-样式-自带样式作用域" class="headerlink" title="2. 样式: 自带样式作用域"></a>2. 样式: 自带样式作用域</h3><p>  <code>*.module.css</code>的命令会自动打包为一个css对象,使用时引入像对象一样使用<br>  <pre><code class="hljs jsx"><span class="hljs-keyword">import</span> loginStyle <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./login.module.css&quot;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">loginStyle.demo</span>&#125;`&#125;&gt;</span>login<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre><br>  动态类名可以结合插件<code>classnames</code>使用</p><h3 id="3-实现-简单路由拦截跳转"><a href="#3-实现-简单路由拦截跳转" class="headerlink" title="3. 实现: 简单路由拦截跳转"></a>3. 实现: 简单路由拦截跳转</h3><p>  版本: react-router-dom 5.2.0<br>  与vue的区别: 没有路由拦截钩子, 听说github上说就是作者希望react-router是灵活的…(这就需要自己封装高阶组件了)<br>  此处为超简单的实现: 没有token则跳Login页<br>    <pre><code class="hljs jsx"><span class="hljs-keyword">const</span> routes = [  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">component</span>: Login&#125;,  &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: Home&#125;,]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyRouter</span> (<span class="hljs-params">route</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#123;route.path&#125;</span> <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">route.component</span> &#123;<span class="hljs-attr">...route</span>&#125; <span class="hljs-attr">routes</span>=<span class="hljs-string">&#123;route.routes&#125;</span> /&gt;</span> &#125; /&gt;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasToken</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> !!db.getValue(<span class="hljs-string">&#x27;Token&#x27;</span>)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; hasToken (): &#x27;</span>,  hasToken ());  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><span class="xml">        &#123;</span><span class="xml">          routes.map((route, i) =&gt; &#123;</span><span class="xml">            return <span class="hljs-tag">&lt;<span class="hljs-name">MyRouter</span> &#123;<span class="hljs-attr">...route</span>&#125; <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> /&gt;</span></span><span class="xml">          &#125;)</span><span class="xml">        &#125;</span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><span class="xml">        &#123;</span><span class="xml">          !hasToken() ?  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">render</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> (<span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;&#123;pathname:</span> &quot;/<span class="hljs-attr">login</span>&quot;&#125;&#125; /&gt;</span>) &#125; /&gt; : &#x27;&#x27;</span><span class="xml">        &#125;</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>  )&#125;</code></pre></p><h3 id="4-实现-动态渲染菜单"><a href="#4-实现-动态渲染菜单" class="headerlink" title="4. 实现: 动态渲染菜单"></a>4. 实现: 动态渲染菜单</h3><p>  <a href="/img/react/menu.png">代码图</a><br>  参照文档: <a href="https://reactjs.org/docs/jsx-in-depth.html#choosing-the-type-at-runtime">https://reactjs.org/docs/jsx-in-depth.html#choosing-the-type-at-runtime</a><br>  数据来源: 本地Mock<br>  <pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Mock.mock(<span class="hljs-string">&#x27;/menu&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>, &#123;  <span class="hljs-attr">isSuccess</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;success&#x27;</span>,  <span class="hljs-attr">records</span>: [    &#123;      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;用户中心&#x27;</span>,      <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;sub1&quot;</span>,      <span class="hljs-attr">children</span>: [        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;组织管理&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;/user/org&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Org&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;a&quot;</span> &#125;,        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;岗位管理&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;/user/station&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Station&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;b&quot;</span> &#125;,        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;/user/user&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;User&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;,      ],    &#125;,    &#123;      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;权限管理&#x27;</span>,      <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;sub2&quot;</span>,      <span class="hljs-attr">children</span>: [        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;菜单配置&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;/auth/menu&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Menu&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;a&quot;</span> &#125;,        &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;角色管理&#x27;</span>, <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;/auth/role&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Role&#x27;</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;b&quot;</span> &#125;,      ],    &#125;,  ],&#125;)</code></pre></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><p>  <strong>Can’t not find Module;</strong><br>  <code>&lt;Route component=&#123;() =&gt; import(&#39;../views&#39; + route.component))&#125;</code><br>  <code>import</code>引包的问题, 没找到一个好的解决办法<br>  <strong>component should be a class/function;</strong><br>  <code>&lt;Route component=&#123;route.component&#125;</code><br>  <code>component=&#123;Demo&#125;</code> 会被编译成React.createElement(Demo,{})这种形式, 故直接返回一个路径字符串会报错，直接返回组件名也会报错<br>  <strong>Suspense…</strong><br>  <code>&lt;Route component=&#123;React.lazy(() =&gt; import(route.component))&#125;</code><br>  lazy不能单独使用, 应该配合Suspense使用</p><h3 id="5-初识-redux"><a href="#5-初识-redux" class="headerlink" title="5. 初识: redux"></a>5. 初识: redux</h3><p>  先上一张百度百科的图<br>  <img src="/img/react/redux.jpg" alt="redux"><br>  与vuex的对比:</p><ol><li><p>同为状态管理器, <code>vuex</code>为vue量身定做; <code>redux</code>就是一个纯JS库, 可以用在其他框架(我自己是没去试过怎么用的)</p></li><li><p>vuex的同步可以使用<code>commit(mutation)</code>, 也可以用<code>dispatch(action)</code>; react同步异步都是用dispatch触发, 同步异步传参不同(这针对现在学的<code>thunk</code>)</p></li><li><p>刷新都会丢失,需要做数据持久化(似乎两个的思想都是来自与<code>flux</code>)</p></li><li><p>解决业务场景问题: 组件之间状态共享 </p><p>redux的使用步骤:</p></li><li><p>创建<code>store</code>, 关联<code>reducer</code></p></li><li><p><code>store.state</code> 与 <code>React Component</code>连接(通过<code>Connect</code> API向<code>Component.prop</code>注入)</p></li><li><p><code>React Component</code> 通过 <code>store.dispatch(action)</code> 调用 <code>reducer</code> 改变 <code>store.state</code></p><pre><code class="hljs js"><span class="hljs-comment">// 创建store</span><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><span class="hljs-keyword">import</span> root <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><span class="hljs-keyword">const</span> store = createStore(root)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<span class="hljs-comment">// reducer</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setToken</span>(<span class="hljs-params">state = <span class="hljs-string">&#x27;&#x27;</span>, action</span>) </span>&#123;  <span class="hljs-keyword">switch</span> (action.type) &#123;    <span class="hljs-keyword">case</span> actionType.SET_TOKEN:      <span class="hljs-keyword">return</span> action.payload    <span class="hljs-attr">default</span>: &#123;      <span class="hljs-keyword">return</span> state    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> combineReducers(&#123;<span class="hljs-attr">tenant</span>: setToken&#125;)<span class="hljs-comment">// store 与 React Component 关联，根组件注入(略)</span><span class="hljs-comment">// action及创建函数</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SET_TOKEN = <span class="hljs-string">&quot;SET_TOKEN&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setToken</span>(<span class="hljs-params">value = <span class="hljs-string">&#x27;&#x27;</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: actionType.SET_TOKEN,    <span class="hljs-attr">payload</span>: value,  &#125;&#125;<span class="hljs-comment">// store与UI关联</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Login</span>(<span class="hljs-params">&#123;handleSetToken&#125;</span>)</span>&#123;  <span class="hljs-comment">// 调用handleSetToken即可更新state</span>&#125;<span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">() =&gt;</span> (&#123;&#125;)<span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> (&#123;  <span class="hljs-attr">handleSetToken</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> dispatch(setToken(value)),&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withRouter(connect(mapStateToProps, mapDispatchToProps)(Login))</code></pre></li></ol><p>  <strong>现阶段存在的一些问题:</strong><br>    -  刷新页面, store的数据会丢失;<br>    -  现在store.dispatch({type})是同步的, 如果异步, 该如何处理. </p><p>  由此, 引入react的一些中间件</p><h3 id="redux-thunk-异步action处理"><a href="#redux-thunk-异步action处理" class="headerlink" title="redux-thunk: 异步action处理"></a>redux-thunk: 异步action处理</h3><p>  <strong><code>redux-thunk</code>帮我们做了什么</strong><br>  在没有引入<code>redux-thunk</code>之前, <code>store.dispatch()</code>的参数只能是一个Object, 引入这个库之后, <code>store.dispatch()</code>的参数可以是<strong>Object || Function</strong><br>  为什么在此阶段处理异步操作:</p><ul><li><p>根据<code>redux</code>的设计原则, reducer应该为纯函数, 不涉及动态数据</p></li><li><p>UI 中触发更改state操作是通过 <code>store.dispatch()</code> 更改  </p><pre><code class="hljs js">createStore(reducer, applyMiddleware(thunk))    <span class="hljs-comment">// 好奇applyMiddleware是如何实现中间件功能的, 现在暂且先会用吧</span><span class="hljs-comment">// action创建函数</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTodoList</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;    dispatch(&#123; <span class="hljs-attr">type</span>: actionType.FETCH_TODO_LIST &#125;)    <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">&#x27;/todo&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      dispatch(&#123;        <span class="hljs-attr">type</span>: actionType.TODO_LIST_RECEIVE,        <span class="hljs-attr">todoList</span>: res.data.records,      &#125;)    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;      dispatch(&#123;        <span class="hljs-attr">type</span>: actionType.TODO_LIST_RECEIVE      &#125;)    &#125;)  &#125;&#125;<span class="hljs-comment">// 其他使用和同步无异</span></code></pre><h3 id="redux-persist-redux数据持久化"><a href="#redux-persist-redux数据持久化" class="headerlink" title="redux-persist: redux数据持久化"></a>redux-persist: redux数据持久化</h3><p><a href="https://github.com/rt2zz/redux-persist">redux-persist文档</a><br><code>redux-persist</code>帮我们做的事: 把state存储到浏览器storage</p><pre><code class="hljs js"><span class="hljs-comment">// persist.js store的创建有所改变</span><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><span class="hljs-keyword">import</span> &#123; persistStore, persistReducer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist&#x27;</span><span class="hljs-keyword">import</span> storage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist/lib/storage&#x27;</span> <span class="hljs-comment">// defaults to localStorage for web</span><span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><span class="hljs-keyword">const</span> persistConfig = &#123;  <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;root&#x27;</span>,  storage,&#125;<span class="hljs-keyword">const</span> persistedReducer = persistReducer(persistConfig, rootReducer)<span class="hljs-keyword">let</span> store = createStore(persistedReducer, applyMiddleware(thunk))<span class="hljs-keyword">let</span> persistor = persistStore(store)<span class="hljs-keyword">export</span> &#123;  store,  persistor&#125;<span class="hljs-comment">// 根组件配置</span><span class="hljs-keyword">import</span> &#123; Provider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><span class="hljs-keyword">import</span> &#123;persistor, store &#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/persist.js&quot;</span><span class="hljs-keyword">import</span> &#123; PersistGate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-persist/es/integration/react&#x27;</span>;ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">PersistGate</span> <span class="hljs-attr">persistor</span>=<span class="hljs-string">&#123;persistor&#125;</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">PersistGate</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于react有初步的了解, 但对于react的开发, 正式环境区分, 生命周期, 高阶组件及mobX状态等了解甚少<br>后续一个方向, 了解react中间件的设计, <code>applyMiddleware</code>的实现, 实现一个不对数据做任何处理的中间件<br>有这种念头是因为, <code>react-redux</code>保证纯洁性的后果是, 所有脏苦累的活都交给中间件去做了</p><p>最后 希望后面自己能对工作中的技术有一个阶段性的总结, 关于工作用到的技术, 关于个人的提升, 关于线下读的书…</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大文件分片上传学习笔记</title>
    <link href="/2020/09/19/chunk-upload/"/>
    <url>/2020/09/19/chunk-upload/</url>
    
    <content type="html"><![CDATA[<p>最近公司业务需要做PC端大文件分片上传, 这里记录一下自己对大文件分片上传的学习</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  <img src="/img/rp/fileUpload.png" alt="chunk"><br>  <strong>分片验证</strong>: 在每个分片上传前都验证此分片是否已上传, 后端返回此分片是否已上传; 又或者是, 后端一次返回所有已上传分片的index, 前端根据此判断哪些分片该跳过, 哪些该上传</p><h2 id="优秀的开源插件"><a href="#优秀的开源插件" class="headerlink" title="优秀的开源插件"></a>优秀的开源插件</h2><ul><li><a href="https://github.com/simple-uploader/Uploader">simple-uploader</a>: 优秀上传库, 支持多并发上传，文件夹、拖拽、可暂停继续、秒传、分块上传、出错自动重传、手工重传、进度、剩余时间、上传速度等特性</li><li><a href="https://github.com/simple-uploader/vue-uploader/blob/master/README_zh-CN.md">vue-simple-uploader</a>: 基于<code>simple-uploader</code>的文件上传封装, 加了一些额外的options</li><li><a href="https://github.com/LuoLiangDSGA/spring-learning/tree/master/boot-uploader">SpringBoot+Vue.js前后端分离实现大文件分块上传</a>: 基于<code>vue-simple-uploader</code> 实现 大文件分片上传</li></ul><h2 id="念叨念叨"><a href="#念叨念叨" class="headerlink" title="念叨念叨"></a>念叨念叨</h2><ol><li>在做文件分片上传之前, 最先看的是 <a href="https://github.com/ElemeFE/element/blob/dev/packages/upload/src/upload.vue">el-upload</a>的源码,  发现把 变量fileList 放在 upload.vue, 很有react状态提升的味道 (我什么时候才能学会用react做项目啊)</li><li>最后因为公司情况 <em>或许某时某刻有些东西真的并不需要太完美</em>,  用了 <a href="http://fex.baidu.com/webuploader/">webuploader</a> , 怎么说呢，这个库并不支持单个文件的暂停/重新上传(即便文档说有支持, 但是测试之后发现并不支持), 这个是不我不太喜欢的地方, 但最后我还是把<code>webuploader</code>封装到我司的开发平台, 毕竟能跑的东西都不会太差</li></ol>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab-ci前端自动发布(简单版)</title>
    <link href="/2020/09/15/gitlab-ci/"/>
    <url>/2020/09/15/gitlab-ci/</url>
    
    <content type="html"><![CDATA[<p>我司所用的自动部署技术栈是gitlab-ci + docker + rancher + harbor, 遂产生了自己手搭一个简单的前端自动部署的念头.<br><em>虚拟机直接使用root用户了, 懒得换</em></p><h2 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h2><p>  系统: centos7 </p><ol><li>安装 gitlab</li><li>安装 nginx</li><li>安装配置 gitlab-runner</li></ol><h2 id="安装并部署-gitlab"><a href="#安装并部署-gitlab" class="headerlink" title="安装并部署 gitlab"></a>安装并部署 gitlab</h2><p>  win10下Hyper-V启动一个centos7虚拟机, 参照以下下命令安装gitlab<br>  官方地址: <a href="https://about.gitlab.com/">gitlab官网</a> <a href="https://gitlab.com/gitlab-org/gitlab-ce">gitlab-ce</a></p><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3>  <pre><code class="hljs shell">yum install -y curl policycoreutils-python openssh-server<span class="hljs-meta">#</span><span class="bash">启动ssh服务&amp;设置为开机启动</span>systemctl enable sshdsystemctl start sshd</code></pre><h3 id="2-安装-Postfix-可跳过"><a href="#2-安装-Postfix-可跳过" class="headerlink" title="2. 安装 Postfix(可跳过)"></a>2. 安装 Postfix(可跳过)</h3>  <pre><code class="hljs shell">yum install -y postfix<span class="hljs-meta">#</span><span class="bash">启动ssh服务&amp;设置为开机启动</span>systemctl enable postfixsystemctl start postfix</code></pre><h3 id="3-开放ssh以及http服务端口-80-8095"><a href="#3-开放ssh以及http服务端口-80-8095" class="headerlink" title="3. 开放ssh以及http服务端口(80,8095)"></a>3. 开放ssh以及http服务端口(80,8095)</h3>  <pre><code class="hljs shell">firewall-cmd --add-service=ssh --permanentfirewall-cmd --add-service=http --permanentfirewall-cmd --zone=public --add-port=8095/tcp --permanentfirewall-cmd --reload<span class="hljs-meta">#</span><span class="bash">重载防火墙规则</span>firewall-cmd --reload</code></pre><h3 id="4-yum-安装gitlab"><a href="#4-yum-安装gitlab" class="headerlink" title="4. yum 安装gitlab"></a>4. yum 安装gitlab</h3>  <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加 package</span>curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 安装 gitlab-ce</span>yum install -y gitlab-ce</code></pre><p>  安装成功之后会打印gitlab图形<br>  <img src="/img/gitlab/gitlab-success.png" alt="gitlab-success"></p><h3 id="5-配置gitlab访问地址"><a href="#5-配置gitlab访问地址" class="headerlink" title="5. 配置gitlab访问地址"></a>5. 配置gitlab访问地址</h3><p>  gitlab的默认配置文件路径 <code>/etc/gitlab/gitlab.rb</code><br>  修改<code>external_url &#39;http://gitlab.example.com&#39;</code><br>  <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 打开配置文件</span>vi /etc/gitlab/gitlab.rb<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 修改配置文件 这里我设置为本机IP:8095</span>external_url &#x27;http://192.168.245.156:8095&#x27;</code></pre><br>  <img src="/img/gitlab/gitlab-url.png" alt="gitlab-url"></p><h3 id="6-重新配置并启动gitlab"><a href="#6-重新配置并启动gitlab" class="headerlink" title="6. 重新配置并启动gitlab"></a>6. 重新配置并启动gitlab</h3>  <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 重新配置</span>gitlab-ctl reconfigure<span class="hljs-meta">#</span><span class="bash"> 完成后会看到以下输出</span>Running handlers completeChef Client finished, 432/613 resources updated in 04 minutes 20 secondsgitlab Reconfigured!<span class="hljs-meta">#</span><span class="bash"> 重启</span>gitlab-ctl restart</code></pre><p>  <img src="/img/gitlab/reconfigure.png" alt="reconfigure"></p><h3 id="7-访问gitlab"><a href="#7-访问gitlab" class="headerlink" title="7. 访问gitlab"></a>7. 访问gitlab</h3><p>  浏览器地址栏输入 <code>http://192.168.245.156:8095/</code> 即可看到gitlab<br>  <strong>第一次登录默认账号 root, 需设置密码</strong></p><h3 id="8-新建一个vue项目"><a href="#8-新建一个vue项目" class="headerlink" title="8. 新建一个vue项目"></a>8. 新建一个vue项目</h3><p>  新建一个vue项目, 方便后面测试<br>  <img src="/img/gitlab/vue-demo.png" alt="vue-demo"></p><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><h3 id="1-添加源"><a href="#1-添加源" class="headerlink" title="1. 添加源"></a>1. 添加源</h3>  <pre><code class="hljs shell">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><h3 id="2-install"><a href="#2-install" class="headerlink" title="2. install"></a>2. install</h3>  <pre><code class="hljs shell">yum install nginx<span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 启动</span>systemctl start nginx.service<span class="hljs-meta">#</span><span class="bash"> 设置开机启动</span>systemctl enable nginx.service</code></pre><p>  <img src="/img/gitlab/nginx.png" alt="nginx"></p><h2 id="安装配置-gitlab-runner"><a href="#安装配置-gitlab-runner" class="headerlink" title="安装配置 gitlab-runner"></a>安装配置 gitlab-runner</h2><p>  <strong>ranner:</strong> 读取并执行项目中的 <code>.gitlab-ci.yml文件</code><br>  <strong>gitlab 打开 setting &gt; CI/CD 下runner选项</strong>, 可以看到url, token的信息, 注册runner需要用到<br>  <img src="/img/gitlab/gitlab-runner.png" alt="gitlab-runner"><br>  <strong>不同版本的gitlab入口也不一样</strong><br>  <img src="/img/gitlab/gitlab-runner2.png" alt="gitlab-runner2"></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3>  <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 添加package</span>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bashyum install gitlab-runner</code></pre><h3 id="2-注册"><a href="#2-注册" class="headerlink" title="2. 注册"></a>2. 注册</h3>  <pre><code class="hljs shell">sudo gitlab-runner register<span class="hljs-meta">#</span><span class="bash"> 填写 url token 相关信息, 选择执行器 shell</span><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"> 注册成功后更改权限</span>sudo chown -R gitlab-runner:gitlab-runner /home/gitlab-runnersudo chmod -R 777 /home/gitlab-runner</code></pre><p>  <img src="/img/gitlab/runner-register.png" alt="runner-register.png"></p><p>  成功之后在CI/CD界面看到<br>  <img src="/img/gitlab/runner-success.png" alt="runner-success.png"></p><h2 id="编写-gitlab-ci-yml-配置文件"><a href="#编写-gitlab-ci-yml-配置文件" class="headerlink" title="编写.gitlab-ci.yml 配置文件"></a>编写.gitlab-ci.yml 配置文件</h2><h3 id="1-本地使用vue-cli初始化一个项目并关联远程仓库"><a href="#1-本地使用vue-cli初始化一个项目并关联远程仓库" class="headerlink" title="1. 本地使用vue-cli初始化一个项目并关联远程仓库"></a>1. 本地使用vue-cli初始化一个项目并关联远程仓库</h3><h3 id="2-项目根目录创建-gitlab-ci-yml文件"><a href="#2-项目根目录创建-gitlab-ci-yml文件" class="headerlink" title="2. 项目根目录创建.gitlab-ci.yml文件"></a>2. 项目根目录创建.gitlab-ci.yml文件</h3>  <pre><code class="hljs yml"><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><span class="hljs-attr">cache:</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span><span class="hljs-attr">build_dev:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">build</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">--registry</span> <span class="hljs-string">https://registry.npm.taobao.org</span> <span class="hljs-string">install</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">rm</span> <span class="hljs-string">-fr</span> <span class="hljs-string">/usr/share/nginx/html/*</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">-f</span> <span class="hljs-string">dist/*</span> <span class="hljs-string">/usr/share/nginx/html</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span>  <span class="hljs-attr">tags:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">runner1</span></code></pre><h3 id="3-查看gitlab构建"><a href="#3-查看gitlab构建" class="headerlink" title="3. 查看gitlab构建"></a>3. 查看gitlab构建</h3><p>  <img src="/img/gitlab/success.png" alt="success"></p><h3 id="4-访问-nginx-验证是否成功"><a href="#4-访问-nginx-验证是否成功" class="headerlink" title="4. 访问 nginx 验证是否成功"></a>4. 访问 nginx 验证是否成功</h3><p>  打开 http:192.168.245.154 即可看到vue界面</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><h3 id="1-fatal-git-fetch-pack-expected-shallow-list"><a href="#1-fatal-git-fetch-pack-expected-shallow-list" class="headerlink" title="1. fatal: git fetch-pack: expected shallow list"></a>1. fatal: git fetch-pack: expected shallow list</h3><p>  原因: git版本太低<br>  <img src="/img/gitlab/git.png" alt="git"><br>  <pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">安装源</span>yum install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm<span class="hljs-meta">#</span><span class="bash">安装git</span>yum install git<span class="hljs-meta">#</span><span class="bash">更新git</span>yum update git</code></pre></p><h3 id="2-npm-is-not-a-command"><a href="#2-npm-is-not-a-command" class="headerlink" title="2. npm is not a command"></a>2. npm is not a command</h3><p>  忘记安装node 及 npm</p><h3 id="3-没有权限读写html-目录"><a href="#3-没有权限读写html-目录" class="headerlink" title="3. 没有权限读写html 目录"></a>3. 没有权限读写html 目录</h3><p>  <img src="/img/gitlab/Q2.png" alt="nginx"><br>  开放权限<br>  <pre><code class="hljs shell">chmod -R 777 /usrchmod -R 777 /usr/sharechmod -R 777 /usr/share/nginxchmod -R 777 /usr/share/nginx/html</code></pre></p><h3 id="4-gitlab-502"><a href="#4-gitlab-502" class="headerlink" title="4. gitlab 502"></a>4. gitlab 502</h3><ul><li>官方解决办法<br><img src="/img/gitlab/502.png" alt="502"></li><li>unicorn[worker_timeout]时间设久一点</li><li>unicorn默认8080端口被占用<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2>这是一个相对简单的前端自动部署, 无论是gitlab, gitlab-runner, nginx都是可以在docker容器中运行的。线下也尝试了以docker方式起nginx的方法, 但是由于发布都要修改镜像名称, 容器名称,(否则会出错), (又或者是在第一次发布之后, 在dockerfile中加入删除镜像, 容器的命令的方法)让我感觉很麻烦, 就没有使用这种方式, 有时间的话后续可以加入 harbor, rancher 做一个完整的自动发布。写着写着快凌晨一点了, <del>good night</del></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端自动发布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elementui-cascader-lazyload</title>
    <link href="/2020/09/14/elementui-cascader-lazyload/"/>
    <url>/2020/09/14/elementui-cascader-lazyload/</url>
    
    <content type="html"><![CDATA[<p>el-cascader动态加载数据, 父子节点不关联单选的情况下, 直接点击radio图标不自动加载下一级的解决办法</p><h2 id="业务背景及问题"><a href="#业务背景及问题" class="headerlink" title="业务背景及问题"></a>业务背景及问题</h2><p>  <strong>业务背景</strong>: 后端无法在初始化的时候返回树状结构的数据(数据是历史遗留问题), 只能根据节点id动态加载子节点数据<br>  <strong>需求</strong>: 可任意选择任意级的选项, 但必须是单选</p><h2 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址"></a>演示地址</h2><p>  <a href="https://codepen.io/honorgo/pen/zYqGLey">codepen地址</a><br>  <strong>问题重现</strong>: 先点击选项1前面的radio框, 下一级无法加载; 只有点击 选项1 的时候下一级才能正常显示;</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>  <strong>解决思路</strong>: 选中radio框的时候, 同样执行类似点击 选项1 的js方法<br>  <pre><code class="hljs vue.js">&lt;template&gt;  &lt;el-cascader :props=&quot;props&quot; ref=&quot;demo&quot; @change=&quot;change&quot;&gt;&lt;/el-cascader&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        props: &#123;          lazy: true,          checkStrictly: true,          lazyLoad(node, resolve) &#123;            const &#123; level &#125; = node;            setTimeout(() =&gt; &#123;              const nodes = Array.from(&#123; length: level + 1 &#125;).map((item) =&gt; (&#123;                value: ++id,                label: `选项$&#123;id&#125;`,                leaf: level &gt;= 2              &#125;));              resolve(nodes);            &#125;, 1000);          &#125;        &#125;      &#125;    &#125;,    methods: &#123;      change() &#123;        let node = this.$refs.demo.getCheckedNodes()[0];        // 防止已加载数据重复加载; 叶子节点不加载下一级        if (node.children &amp;&amp; node.children.length == 0 &amp;&amp; !node.isLeaf)          this.$refs.demo.$refs.panel.lazyLoad(node);      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elementUI vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/11/hello-world/"/>
    <url>/2020/09/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><!-- <p class="note note-primary">标签</p><p class="note note-secondary">标签</p><p class="note note-success">标签</p><p class="note note-danger">标签</p><p class="note note-warning">标签</p><p class="note note-info">标签</p><p class="note note-light">标签</p> --><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
